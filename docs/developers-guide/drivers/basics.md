# Database driver basics

A Metabase driver:

- **Provides Metabase with basic information for the database** such as the database's capabilities, connection properties, and so on.
- **Provides Metabase with information about the schema of the database** -- the tables (or equivalent), the fields in those tables, the foreign key relationships (for databases that support foreign keys).
  - This functionality is used by the Metabase _sync process_ and stored in the application database.
  - The stored information is used in the visual Query Builder and other places to show users what tables/columns/etc. are available
- **Compiles our in-house query language, [MBQL](https://github.com/metabase/metabase/wiki/Query-Language-'98), into native queries.**
  - MBQL queries are generated by the visual query builder.
  - The Metabase **query processor\*** converts MBQL queries to native queries
- **Executes native queries and returns results**.

## How are Metabase drivers written?

Let's take a high-level look at the [SQLite driver](https://github.com/metabase/metabase/tree/master/modules/drivers/sqlite): 

```
|-- deps.edn
|-- resources
|   `-- metabase-plugin.yaml
|-- src
|   `-- metabase
|       `-- driver
|           `-- sqlite.clj
`-- test
    `-- metabase
        |-- driver
        |   `-- sqlite_test.clj
        `-- test
            `-- data
                `-- sqlite.clj
```

### `deps.edn`

The `deps.edn` file specifies your driver's dependencies.

### `resources/metabase-plugin.yaml`

Your driver's manifest.

## A minimalist driver

But first, let's focus on the main driver file for our Fox Pro '98.

Take a look at this sample code.

```clj
;; Define a namespace for the driver
(ns com.mycompany.metabase.driver.foxpro98
  (:require [metabase.driver :as driver]))

;; You must register a driver for it to work
(driver/register! :foxpro98)

;; Name for humans
(defmethod driver/display-name :foxpro98 [_]
  "Visual FoxPro '98")
```

So, what's going on here?

## Driver namespaces

```
;; Define a namespace for the driver
(ns com.mycompany.metabase.driver.foxpro98
  (:require [metabase.driver :as driver]))
```

**Typically, each Metabase driver lives in its own namespace** -- `com.mycompany.metabase.driver.foxpro98` in this case. All core Metabase drivers live in `metabase.driver.*` namespaces, but feel free to call your namespace whatever you want (unless your goal is to your driver merged into the core Metabase repo, in which case you'll need to stick to `metabase.driver.<driver-name>`). It's probably best to use names that follow the [Java package naming conventions](https://en.wikipedia.org/wiki/Java_package#Package_naming_conventions).

**Many drivers are further broken out into additional namespaces**, especially larger drivers. Commonly, a driver will have a `query-processor` namespace (e.g., `com.mycompany.metabase.driver.foxpro98.query-processor`) that contains the logic for converting MBQL queries into native ones. The query processor is often the most complicated part of a driver, so keeping that logic separate can help make things easier to work with. Some drivers also have a separate `sync` namespace that has implementations for methods used by the sync process.

### Driver registration

The very first call after the namespace declaration in the example above was a call to `metabase.driver/register-driver!`:

```clj
;; You must register a driver for it to work
(driver/register! :foxpro98)
```

**All Metabase drivers must be registered before use.** For drivers shipped as separate plugins, Metabase will register the plugin automatically. More on plugins later.

## `metabase.driver` multimethods

The [`metabase.driver` namespace](https://github.com/metabase/metabase/blob/master/src/metabase/driver.clj) defines a series of [multimethods](https://clojure.org/reference/multimethods), and drivers provide implementations for them, as in our example:

```clj
(defmethod driver/display-name :foxpro98 [_]
  "Visual FoxPro '98")
```

The four main features of a Metabase driver described above are all implemented by multimethods. These methods dispatch on the driver's keyword, `:foxpro98` in our case. In fact, that's all a Metabase driver is -- a keyword! There are no classes or objects to be seen -- just a single keyword.

You can browse the `metabase.driver` namespace for a complete list of multimethods that you could implement. Read the docstring for each method and decide whether you need to implement it. Many methods are optional.

#### Getting a list of all driver multimethods

To quickly look up a list of all driver multimethods, you can run the command

```
clojure -M:run driver-methods
```

which will print a list of all driver namespaces and multimethods. This includes many things like `sql` and `sql-jdbc` multimethods, as well as test extension multimethods. Test extensions will be covered in a later chapter.

### Parent drivers

Many drivers share a lot in common, and writing complete implementations for sync methods and the like would involve a lot of duplicate code. Thus **many high-level features are partially or fully implemented in shared "parent" drivers**, such as the most common parent, `:sql-jdbc`. A "parent" driver is analogous to a superclass in object-oriented programming.

You can define a driver parent when you register it:

```clj
(driver/register! :postgres, :parent :sql-jdbc)
```

Note that for drivers packaged as separate plugins, you do not need to do this; instead, list the parent in the plugin manifest (discussed in upcoming chapters).

Parents like `:sql-jdbc` are intended as a common abstract "base class" for drivers that can share much of their implementation; in the case of `:sql-jdbc`, it's intended for SQL-based drivers that use a JDBC driver under the hood.`:sql-jdbc` and other parents provide implementations for many of the methods needed to power the four main features of a Metabase driver. In fact, `:sql-jdbc` provides implementations of things like `driver/execute-query`, so a driver using it as a parent does not need to provide one itself. However, various parent drivers define their own multimethods to implement.

## Notable parent drivers

- `:sql-jdbc` can be used as the parent for SQL-based databases with a JDBC driver.
  - `:sql-jdbc` implements most of the four main features, but instead you must implement `sql-jdbc` multimethods found in `metabase.driver.sql-jdbc.*` namespaces, as well as some methods in `metabase.driver.sql.*` namespaces
- `:sql` is itself the parent of `:sql-jdbc`; it can be used for SQL-based databases that _do not_ have a JDBC driver, such as BigQuery.
  - `:sql` implements a significant chunk of driver functionality, but you must implement some methods found in `metabase.driver.sql.*` namespaces to use it
- Drivers that use Google's API, such as BigQuery and Google Analytics, can use the `:google` driver as a parent
- Some drivers use other "concrete" drivers as their parent -- for example, `:redshift` uses `:postgres` as a parent, only supplying method implementations to override postgres ones where needed

#### Calling parent driver implementations

You can get a parent driver's implementation for a method by using `get-method`:

```clj
(defmethod driver/mbql->native :bigquery [driver query]
  ((get-method driver/mbql-native :sql) driver query))
```

This is the equivalent of calling `super.someMethod()` is OO-programming. Note that **it is important to pass the driver argument to the parent implementation as-is**, so any methods called by that method used the correct implementation. Here's two ways of calling parents that you should avoid:

```clj
(defmethod driver/mbql->native :bigquery [_ query]
  ;; BAD! If :sql's implementation of mbql->native calls any other methods, it won't use the :bigquery implementation
  ((get-method driver/mbql->native :sql) :sql query))
```

```clj
(defmethod driver/mbql->native :bigquery [_ query]
  ;; BAD! If someone else creates a driver using :bigquery as a parent, any methods called by :sql's implementation
  ;; of mbql->native will use :bigquery method implementations instead of custom ones for that driver
  ((get-method driver/mbql->native :sql) :bigquery query))
```

#### Multiple parents

The astute may have noticed that BigQuery is mentioned as having both `:sql` and `:google` as a parent -- the equivalent of OO "multiple inheritance". This is allowed and helpful! You can define a driver with multiple parents as follows:

```clj
(driver/register! :bigquery, :parent #{:sql :google})
```
In some cases, both parents may provide an implementation for a method; to fix this ambiguity, simply provide an implementation for your driver and pass them to the preferred parent driver's implementation as described above.

For drivers shipped as a plugin, you'll register methods in the plugin manifest.

## Next Up

Packaging a driver as a [plugin](plugins.md).
